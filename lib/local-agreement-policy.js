/**
 * Implements the LocalAgreement-2 policy for streaming transcription.
 * This policy compares the current full ASR output with the previous full ASR output
 * to find the longest common prefix (LCP). The part of this LCP that has not
 * yet been emitted is then confirmed and returned.
 *
 * This implementation is based on the description in the paper "Turning Whisper into
 * Real-Time Transcription System" by Macháček et al. (2023), specifically
 * aligning with Figure 1 and the LocalAgreement section.
 */
class LocalAgreementPolicy {
    constructor() {
        /**
         * @private
         * Stores the complete ASR output from the previous processing step.
         * This is used for comparison with the current ASR output.
         * Corresponds to `output` at N-1 in Figure 1.
         * @type {string}
         */
        this._previousFullASROutput = "";

        /**
         * @private
         * Stores the total text that has been confirmed and emitted so far.
         * This is used to determine which part of the LCP is "newly" confirmed.
         * Corresponds to `confirmed output` in Figure 1 (the accumulated green text).
         * @type {string}
         */
        this._emittedText = "";
    }

    /**
     * Calculates the longest common prefix of two strings.
     * This function performs a token-based comparison, where tokens are
     * sequences of non-whitespace characters (words/punctuation) or
     * sequences of whitespace characters. This approach helps maintain
     * word integrity and handles varying internal spacing, as implied by the
     * examples in the paper's Figure 1.
     *
     * @private
     * @param {string} s1 - The first string.
     * @param {string} s2 - The second string.
     * @returns {string} The longest common prefix of the two strings,
     *                   preserving original token boundaries.
     */
    _getLongestCommonTokenPrefix(s1, s2) {
        // Use a regex to split into tokens: non-whitespace sequences OR whitespace sequences.
        // This ensures that "Hello world." becomes ["Hello", " ", "world", "."]
        // and "Hello  world" becomes ["Hello", "  ", "world"], preserving spacing information.
        const tokens1 = s1.match(/\S+|\s+/g) || [];
        const tokens2 = s2.match(/\S+|\s+/g) || [];

        let lcpText = "";
        let i = 0;
        // Iterate as long as tokens exist in both arrays and are identical
        while (i < tokens1.length && i < tokens2.length && tokens1[i] === tokens2[i]) {
            lcpText += tokens1[i]; // Append the common token to the LCP
            i++;
        }
        return lcpText;
    }

    /**
     * Processes a new full transcript generated by the ASR model.
     * Based on the LocalAgreement-2 policy, it determines and returns
     * the text that can be newly confirmed.
     *
     * @param {string} currentFullASROutput - The complete transcription
     *   from the most recent ASR run on the accumulated audio buffer.
     * @returns {string} The portion of the transcript that is newly confirmed
     *   and should be emitted. Returns an empty string if nothing new can be
     *   confirmed yet (e.g., on the first run, or if the outputs are still
     *   fluctuating at the beginning).
     */
    process(currentFullASROutput) {
        let newlyConfirmed = "";

        if (this._previousFullASROutput === "") {
            // This is the very first ASR output received.
            // With LocalAgreement-2, we need at least two outputs to find a common prefix
            // and determine what is stable. So, nothing is confirmed yet.
        } else {
            // Find the longest common prefix between the previous full ASR output
            // and the current full ASR output.
            const lcp = this._getLongestCommonTokenPrefix(
                this._previousFullASROutput,
                currentFullASROutput
            );

            // The 'newlyConfirmed' part is the portion of the LCP that extends
            // beyond what has already been emitted (i.e., beyond `this._emittedText`).
            // This ensures we only emit text that hasn't been emitted before.
            if (lcp.length > this._emittedText.length) {
                newlyConfirmed = lcp.substring(this._emittedText.length);
            }


            // Update the total emitted text by appending the newly confirmed part.
            this._emittedText += newlyConfirmed;
        }

        // Store the current full ASR output to be used as the 'previous' output
        // in the next iteration's comparison. Ensure it's always a string.
        this._previousFullASROutput = typeof currentFullASROutput === 'string' ? currentFullASROutput : "";

        return newlyConfirmed;
    }

    /**
     * Resets the policy's internal state.
     * Call this when starting a completely new transcription session,
     * or if a significant break in audio/context occurs (e.g., switching speakers).
     */
    reset() {
        this._previousFullASROutput = "";
        this._emittedText = "";
    }

    /**
     * Gets the full transcript that has been confirmed and emitted so far.
     * This represents the stable portion of the transcription.
     * @returns {string} The accumulated confirmed transcript.
     */
    getEmittedText() {
        return this._emittedText;
    }

    /**
     * Gets the last full ASR output received by the policy.
     * This represents the current best guess for the entire audio buffer processed so far,
     * including both confirmed and unconfirmed parts.
     * @returns {string} The last full ASR output.
     */
    getCurrentFullASROutput() {
        return this._previousFullASROutput;
    }

    /**
     * Gets the unconfirmed part of the last full ASR output.
     * This is the portion of the latest ASR output that extends beyond
     * the currently emitted (confirmed) text. This can be useful for displaying
     * "pending" or "draft" text to the user, providing immediate feedback
     * before it's fully confirmed.
     * @returns {string} The unconfirmed part of the latest ASR output.
     */
    getUnconfirmedPart() {
        if (this._previousFullASROutput.length > this._emittedText.length) {
            return this._previousFullASROutput.substring(this._emittedText.length);
        }
        return "";
    }
}

// Export the class for use in other modules
export default LocalAgreementPolicy;
